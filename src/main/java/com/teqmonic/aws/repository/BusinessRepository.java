package com.teqmonic.aws.repository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Repository;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBQueryExpression;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;
import com.amazonaws.services.dynamodbv2.model.ComparisonOperator;
import com.amazonaws.services.dynamodbv2.model.Condition;
import com.teqmonic.aws.model.Business;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Repository
public class BusinessRepository {

	private final DynamoDBMapper dynamoDBMapper;
	
	/**
	    Retrieve a specific item using partition key and range key,
	    no need to pass range key if it isn't defined in the table
	 **/
	public Business getBusinessById(String id, String dateRange) {
		return dynamoDBMapper.load(Business.class, id, dateRange);
	}
	
	/**
	 * We can pass partition id if we need custom id else random UUID would be set due to @DynamoDBAutoGeneratedKey
	 * 
	 * @param business
	 */
	public void saveBusinessDetails(Business business) {
		dynamoDBMapper.save(business);
	}
	
	public void updateBusinessDetails(String id, String dateRange, int numberOfEmployees) {
		Business business = dynamoDBMapper.load(Business.class, id, dateRange);
		business.setNumberOfEmployees(Double.valueOf(numberOfEmployees));
		dynamoDBMapper.save(business);
	}
	
	public List<Business> queryBusinessDetailsUsingLSI(String id, String date) {
		
		// Date of commencement column is a range key in DynamoDB
		Condition dateRangeKeyCondition = new Condition();
		dateRangeKeyCondition.withComparisonOperator(ComparisonOperator.EQ);
		dateRangeKeyCondition.withAttributeValueList(new AttributeValue().withS(date));

		// Rank column is LSI
		Condition rankRangeKeyCondition = new Condition();
		rankRangeKeyCondition.withComparisonOperator(ComparisonOperator.GE);
		rankRangeKeyCondition.withAttributeValueList(new AttributeValue().withN("0"));
		
		// DYnamoDB do not support query on multiple range keys
		Map<String, Condition> conditionMap = new HashMap<>();
		conditionMap.put("date_of_commencement", dateRangeKeyCondition);
		//conditionMap.put("rank", rankRangeKeyCondition);
		
		
		// we cannot query for columns other than partition key, range key, indexes
		
		
		DynamoDBQueryExpression<Business> dynamoDBQueryExpression = new DynamoDBQueryExpression<Business>()
		      .withHashKeyValues(Business.builder().id(id).build())
		      //.withRangeKeyCondition("date_of_commencement", rangeKeyCondition); // another way
		      .withRangeKeyConditions(conditionMap);
		      //.withLimit(10) // default it returns 4 MB of data if no limit is set
		
		return dynamoDBMapper.query(Business.class, dynamoDBQueryExpression);
	}
	
	public List<Business> queryBusinessDetailsUsingGSI(String name) {
		
		DynamoDBQueryExpression<Business> dynamoDBQueryExpression = new DynamoDBQueryExpression<Business>()
			      .withHashKeyValues(Business.builder().name(name).build())
			      .withIndexName("name-gsi")
			      .withConsistentRead(false); // Mandatory to set as false, Consistent reads are not supported on global secondary indexes
			      //.withLimit(10)
		
		return dynamoDBMapper.query(Business.class, dynamoDBQueryExpression);
	}
	
	public void deleteBusinessDetails(String id, String dateRange) {
		Business business = dynamoDBMapper.load(Business.class, id, dateRange);	
		dynamoDBMapper.delete(business);
		//dynamoDBMapper.batchDelete(t1,t2,t3);
	}

}
